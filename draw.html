<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Draw and Predict</title>
    <style>
        canvas {
            border: 1px solid black;
        }
    </style>
</head>
<body>
    <h1>Draw a Digit</h1>
    <canvas id="drawingCanvas" width="28" height="28"></canvas>
    <button id="getPixelData">Predict</button>
    <button id="downloadImage">Download Image</button>

    <p id="predictionResult">Predicted Digit: </p>

    <!-- Load TensorFlow.js Library -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <!-- Load the script file -->
    <!-- <script src="script.js"></script> -->
    <script>
        document.addEventListener("DOMContentLoaded", () => {
        const canvas = document.getElementById('drawingCanvas');
        const context = canvas.getContext('2d');
        context.fillStyle = 'white';
        context.fillRect(0, 0, 28, 28);
        context.imageSmoothingEnabled = true;
        context.webkitImageSmoothingEnabled = false;
        context.mozImageSmoothingEnabled = false;


        let drawing = false;
        // context.fillStyle = 'black';
        // context.fillRect(5, 5, 18, 18);

        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mousemove', draw);

        document.getElementById('downloadImage').addEventListener('click', () => {
                const link = document.createElement('a');
                link.href = canvas.toDataURL('image/png');
                link.download = 'drawing.png';
                link.click();
            });
            
        function startDrawing(event) {
            drawing = true;
            draw(event);
        }

        function stopDrawing() {
            drawing = false;
            context.beginPath();
        }

        function draw(event) {
            if (!drawing) return;

            context.lineWidth = 3;
            context.lineCap = 'round';
            context.strokeStyle = 'black';

            context.lineTo(event.clientX - canvas.offsetLeft, event.clientY - canvas.offsetTop);
            context.stroke();
            context.beginPath();
            context.moveTo(event.clientX - canvas.offsetLeft, event.clientY - canvas.offsetTop);
        }   

        // setInterval(() => {sendImage()}, 1000)
        function sendImage() {
            const imageData = canvas.toDataURL('image/png').split(',')[1];
            fetch('http://127.0.0.1:5000/predict', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ image: imageData }),
            })
            .then(response => response.json())
            .then(data => {
                console.log(`Prediction: ${data.prediction}`)
            })
            .catch(error => {
                console.error('Error:', error);
            });
        }

        
        document.getElementById('getPixelData').addEventListener('click', async () => {
            // sendImage()
            const grayPixels = getPixelData(context, canvas.width, canvas.height);
            // console.log(grayPixels)
            // const image = grayPixels.reshape([28, 28, 1]);
            // console.log(image)
            const data = JSON.stringify({ pixelData: grayPixels });
            // console.log(data)
            fetch('http://127.0.0.1:5000/predict', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: data
                })  
                .then(response => response.json())
                .then(data => {
                    console.log(data)
                })
                .catch(error => {
                    console.error('Error:', error);
                });

            // console.log(response)
            // console.log(grayPixels)
            // const predictedDigit = await predictDigit(grayPixels);
            // document.getElementById('predictionResult').innerText = `Predicted Digit: ${predictedDigit}`;
        });

        function getPixelData(context, width, height) {
            const imageData = context.getImageData(0, 0, width, height);
            const pixels = imageData.data;
            // console.log(pixels)
            // Reshape the pixel data to match the image dimensions (width x height x 4)
            let formattedData = [];
            for (let i = 0; i < 28; i++) {
            let row = [];
            for (let j = 0; j < 28; j++) {
                let index = (i * 28 + j) * 4; // Each pixel has 4 values (RGBA)
                let grayscaleValue = pixels[index] / 255.0; // Since the image is red, R value represents intensity
                row.push([grayscaleValue]); // Push the grayscale value as an array to match TensorFlow's img_to_array format
            }
            formattedData.push(row);
            }
            formattedData = [formattedData]; // Add batch dimension

            console.log(formattedData)


            return formattedData;
        }   

    });



    </script>
</body>
</html>
